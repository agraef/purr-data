#==============================================================================#
#
# Centralized cross-platform build system Makefile.buildsystem
#
# this file contains all the common locations and targets
#  <hans@at.or.at>
#
#==============================================================================#
# This file should be exactly the same in each section of the CVS.  A copy is
# kept in each section of the CVS so that each section will be self-contained.
# To use it, you need to include it in your Makefile (i.e. "include
# Makefile.buildlayout") and then define $(prefix) and $(cvs_root_dir).
#
# $(cvs_root_dir) is the base directory of src tree, equivalent to the root
# level of the pure-data CVS.
#
# $(prefix) is the base directory to where all of the resulting files
# will be copied.
#
# This file is currently located in these places: 
#	  abstractions
#    extensions
#	  externals
# 	  packages
#    doc
#
# it will be going here too:
#    gem
#    pd
#
# <hans@at.or.at>

#==============================================================================#
#
## PLATFORM-SPECIFIC SETTINGS
#
#==============================================================================#
# which OS to compile for
UNAME := $(shell uname -s)
ifeq ($(UNAME),Linux)
  OS_NAME = linux
  EXTENSION = pd_linux
  DYLIB_EXTENSION = so
endif
ifeq ($(UNAME),Darwin)
  OS_NAME = darwin
  EXTENSION = pd_darwin
  DYLIB_EXTENSION = dylib
endif
ifeq (MINGW,$(findstring MINGW,$(UNAME)))
  OS_NAME = windows
  EXTENSION = dll
  DYLIB_EXTENSION = dll
endif
ifeq (CYGWIN,$(findstring CYGWIN,$(UNAME)))
  OS_NAME = windows
  EXTENSION = dll
  DYLIB_EXTENSION = dll
endif
# which CPU to compile for
UNAME_MACHINE := $(shell uname -m)
ifeq ($(UNAME_MACHINE),i386)
  ARCH = i386
endif
ifeq ($(UNAME_MACHINE),i686)
  ARCH = i386
endif
ifeq ($(UNAME_MACHINE),ppc)
  ARCH = powerpc
endif

#==============================================================================#
#
## CFLAGS
#
#==============================================================================#

# base level optimizations
OPT_CFLAGS = -O2

DEBUG_CFLAGS = -ggdb

#==============================================================================#
#
# DIRECTORY STRUCTURE
#
#==============================================================================#

# sources
abstractions_src = $(cvs_root_dir)/abstractions
doc_src = $(cvs_root_dir)/doc
extensions_src = $(cvs_root_dir)/extensions
externals_src = $(cvs_root_dir)/externals
flext_src = $(cvs_root_dir)/externals/grill/flext
gem_src = $(cvs_root_dir)/Gem
packages_src = $(cvs_root_dir)/packages
pd_src = $(cvs_root_dir)/pd
scripts_src = $(cvs_root_dir)/scripts


# destinations
bindir = $(prefix)/bin
includedir = $(prefix)/include
mandir = $(prefix)/man

libdir = $(prefix)/lib
ifeq ($(OS_NAME),darwin)
  libpddir = $(prefix)
  libpdbindir = $(bindir)
  else
    ifeq ($(OS_NAME),windows)
      libpddir = $(prefix)
      libpdbindir = $(bindir)
    else
      libpddir = $(libdir)/pd-l2ork
      libpdbindir = $(libpddir)/bin
    endif
endif

objectsdir = $(libpddir)/extra
pddocdir = $(libpddir)/doc
examplesdir = $(pddocdir)/examples
helpdir = $(pddocdir)/5.reference
manualsdir = $(pddocdir)/manuals
readmesdir = $(manualsdir)/READMEs


#==============================================================================#
#
# DIRECTORY STRUCTURE TARGETS
#
#==============================================================================#

# first make sure that the directory structure is setup
$(DESTDIR):
	install -d $(DESTDIR)

$(bindir): $(DESTDIR)
	install -d $(DESTDIR)$(bindir)

$(examplesdir): $(DESTDIR)
	install -d $(DESTDIR)$(examplesdir)

$(includedir): $(DESTDIR)
	install -d $(DESTDIR)$(includedir)

$(pddocdir): $(DESTDIR)
	install -d $(DESTDIR)$(pddocdir)

$(helpdir): $(DESTDIR)
	install -d $(DESTDIR)$(helpdir)

$(manualsdir): $(DESTDIR)
	install -d $(DESTDIR)$(manualsdir)

$(objectsdir): $(DESTDIR)
	install -d $(DESTDIR)$(objectsdir)

$(readmesdir): $(manualsdir)
	install -d $(DESTDIR)$(readmesdir)

installdirs: $(DESTDIR) $(bindir) $(examplesdir) $(pddocdir) $(includedir) $(helpdir) $(manualsdir) $(objectsdir) $(readmesdir)

#==============================================================================#
#
# PD VERSION AND PACKAGE NAMING
#
#==============================================================================#


# AG: "Abandon hope all ye who enter here." Past this point lies madness. Most
# of Pd's version information is kept in m_pd.h, but some of it needs to be
# generated at build time to keep in sync with git sources. Since we don't
# want to have files in the repo which get updated with every build, we use a
# template m_pd.h.in for m_pd.h instead. The stable version parts (only
# updated by editing m_pd.h.in manually) can be read from there.

PD_MAJOR_VERSION := $(shell grep PD_MAJOR_VERSION $(pd_src)/src/m_pd.h.in | \
	sed 's|^.define *PD_MAJOR_VERSION *\([0-9]*\).*|\1|' )
PD_MINOR_VERSION := $(shell grep PD_MINOR_VERSION $(pd_src)/src/m_pd.h.in | \
	sed 's|^.define *PD_MINOR_VERSION *\([0-9]*\).*|\1|' )
PD_BUGFIX_VERSION := $(shell grep PD_BUGFIX_VERSION $(pd_src)/src/m_pd.h.in | \
	sed 's|^.define *PD_BUGFIX_VERSION *\([0-9]*\).*|\1|' )
#PD_TEST_VERSION := $(shell grep PD_TEST_VERSION $(pd_src)/src/m_pd.h | \
#	sed 's|^.define *PD_TEST_VERSION *"\(.*\)".*|\1|' )
#PD_VERSION = $(PD_MAJOR_VERSION).$(PD_MINOR_VERSION).$(PD_BUGFIX_VERSION)
#ifneq ($(PD_TEST_VERSION),)
#	PD_VERSION := $(PD_VERSION)-$(PD_TEST_VERSION)
#endif

# AG: Pd-l2ork version number. This becomes part of the PD_VERSION.
# It comes from the m_pd.h.in file and will be something like 1.x for
# "classic" Pd-l2ork and 2.x for the new nw.js version.
PD_L2ORK_VERSION := $(shell grep PD_L2ORK_VERSION $(pd_src)/src/m_pd.h.in | \
	sed 's|^.define *PD_L2ORK_VERSION *"\(.*\)".*|\1|' )

# AG: version number based on the actual git revision and date. We use this
# both for the PD_TEST_VERSION and for the package name and accompanying
# materials (ReadMe files and such). Note that this will only work when
# building directly from a clone of the git repo, and of course you'll need to
# have git installed.
GIT_VERSION := $(shell git log -1 --format=%cd --date=short | sed -e 's/-//g')-rev.$(shell git rev-parse --short HEAD)

# AG: Untangle the hall of mirrors that is PD_TEST_VERSION. m_pd.h won't exist
# or will at least be outdated when the build starts, so we can't simply read
# it from there. Since we always use the package version (git revision and
# date, see GIT_VERSION below), we just set it directly instead.

PD_TEST_VERSION := $(GIT_VERSION)

# AG: This is being used for the package name and accompanying materials. For
# Pd-l2ork the vanilla Pd version numbers are rather meaningless (they are
# mainly kept around so that 3rd party externals and abstractions know what
# iteration of the vanilla API they have available). Instead, we use a version
# number derived from PD_L2ORK_VERSION and PD_TEST_VERSION.
PD_VERSION := $(PD_L2ORK_VERSION)-$(PD_TEST_VERSION)

VERSION_DATE := $(shell date +%Y%m%d)

APPLICATION_NAME = Pd-l2ork
PACKAGE_NAME = $(APPLICATION_NAME)-$(PD_VERSION)-`uname -m`


#==============================================================================#
#
# CLEAN TARGETS
#
#==============================================================================#

applications_clean:
	-rm -f -- $(DESTDIR)$(examplesdir)/*/*/*/*/*.*
	-rm -f -- $(DESTDIR)$(examplesdir)/*/*/*/*.*
	-rm -f -- $(DESTDIR)$(examplesdir)/*/*/*.*
	-rm -f -- $(DESTDIR)$(examplesdir)/*/*.*
	-rmdir $(DESTDIR)$(examplesdir)/*/*/*/*
	-rmdir $(DESTDIR)$(examplesdir)/*/*/*
	-rmdir $(DESTDIR)$(examplesdir)/*/*
	-rmdir $(DESTDIR)$(examplesdir)/*
	-rmdir $(DESTDIR)$(examplesdir)


help_clean:
	-rm -f -- $(DESTDIR)$(helpdir)/*/*/*.*
	-rm -f -- $(DESTDIR)$(helpdir)/*/*.*
	-rm -f -- $(DESTDIR)$(helpdir)/*.*
	-rmdir $(DESTDIR)$(helpdir)/*/*
	-rmdir $(DESTDIR)$(helpdir)/*
	-rmdir $(DESTDIR)$(helpdir)


manuals_clean:
	-rm -f -- $(DESTDIR)$(manualsdir)/*/*/*.*
	-rm -f -- $(DESTDIR)$(manualsdir)/*/*.*
	-rmdir $(DESTDIR)$(manualsdir)/*/*
	-rmdir $(DESTDIR)$(manualsdir)/*
	-rmdir $(DESTDIR)$(manualsdir)


objects_clean:
	-rm $(DESTDIR)$(objectsdir)/*/*/*.pd
	-rm $(DESTDIR)$(objectsdir)/*/*.pd
	-rm $(DESTDIR)$(objectsdir)/*.pd
	-rm $(DESTDIR)$(objectsdir)/*/*/*.$(EXTENSION)
	-rm $(DESTDIR)$(objectsdir)/*/*.$(EXTENSION)
	-rm $(DESTDIR)$(objectsdir)/*.$(EXTENSION)
	-rmdir $(DESTDIR)$(objectsdir)/*/*
	-rmdir $(DESTDIR)$(objectsdir)/*
	-rmdir $(DESTDIR)$(objectsdir)


install_clean: applications_clean help_clean manuals_clean objects_clean
	-rmdir $(DESTDIR)$(pddocdir)
	-rmdir $(DESTDIR)$(prefix)
	-rmdir $(DESTDIR)
	@echo " "
	@echo "Build destination cleaned: $(DESTDIR)"


cruft_clean:
# emacs litter
	-rm -f -- */*/*/*/*.*~
	-rm -f -- */*/*/*.*~
	-rm -f -- */*/*.*~
	-rm -f -- */*.*~
	-rm -f -- *.*~
	-rm -f -- Makefile~ Makefile.buildlayout~
# sed replace litter
	-rm -f -- */*/*/*/*.bak
	-rm -f -- */*/*/*.bak
	-rm -f -- */*/*.bak
	-rm -f -- */*.bak
	-rm -f -- *.bak
# patching replace litter
	-rm -f -- */*/*/*/*.rej
	-rm -f -- */*/*/*.rej
	-rm -f -- */*/*.rej
	-rm -f -- */*.rej
	-rm -f -- *.rej
# autoconf cache
	-rm -rf -- */*/*/*/autom4te.cache
	-rm -rf -- */*/*/autom4te.cache
	-rm -rf -- */*/autom4te.cache
	-rm -rf -- */autom4te.cache
	-rm -rf -- autom4te.cache


